
/* DATA REGISTERS : 32 BITS */
var D = new Uint32Array( 8 );
/* these are general-purpose data registers */

/* ADDRESS REGISTERS : 32 BITS */
var A = new Uint32Array( 8 );
/* these are used as pointers, generally */

/* STACK POINTER : 32 BITS */
// A[7] is the stack pointer

/**
 * In the supervisor programming model register, A7 refers to the interrupt stack pointer,
 * A7’(ISP) and the master stack pointer, A7" (MSP). The supervisor stack pointer is the active
 * stack pointer (ISP or MSP). For processors that do not support ISP or MSP, the system stack
 * is the system stack pointer (SSP). The ISP and MSP are general- purpose address registers
 * for the supervisor mode. They can be used as software stack pointers, index registers, or
 * base address registers. The ISP and MSP can be used for word and long-word operations.
 */
/**
 * Register A7 is used as a hardware stack pointer during stacking for subroutine calls and
 * exception handling. In the user programming model, A7 refers to the user stack pointer
 * (USP).
 */

/* PROGRAM COUNTER : 32 BITS */
var PC = new Uint8Array(1);
/**
 * The PC contains the address of the instruction currently executing. During instruction
 * execution and exception processing, the processor automatically increments the contents
 * or places a new value in the PC. For some addressing modes, the PC can be used as a
 * pointer for PC relative addressing.
 */

/* STATUS REGISTER : 32 BITS */
var SR = new Uint8Array(1);
/*
    15   14  13  12  11  10  9   8   7   6   5   4   3   2   1   0
    T1   T0  S   M   0   I2  I1  I0  0   0   0   X   N   Z   V   C

    Bit Description
    C   Carry
    V   Overflow
    Z   Zero
    N   Negative
    X   Extend
    I0  Interrupt priority mask bit 1
    I1  Interrupt priority mask bit 2
    I2  Interrupt priority mask bit 3
    M   Master/Interrupt switch. Determines which stack mode to use if S is set. If M is clear, SP refers to ISP, else SP refers to MSP. This bit is always clear on processor models lower than 68020.
    S   Supervisor Mode flag. If clear, SP refers to USP. If set, look at M to determine what stack SP points to.
    T0  Trace bit 1. If set, trace on change of program flow. This bit is always cleared on processor models lower than 68020.
    T1  Trace bit 2. If set, trace is allowed on any instruction. DO NOT SET BOTH TRACE BITS AT THE SAME TIME!

    (in user mode, only the low bit is accessible.  in supervisor mode, all bits can be read)
*/

/* CONDITION CODE REGISTER : 8 BITS */
var CCR = new Uint8Array(1);
/**
 * 1.1.4 Condition Code Register
 *
 * Consisting of five bits, the CCR, the status register’s lower byte, is the only portion of the
 * status register (SR) available in the user mode. Many integer instructions affect the CCR,
 * indicating the instruction’s result. Program and system control instructions also use certain
 * combinations of these bits to control program and system flow. The condition codes meet
 * two criteria: consistency across instructions, uses, and instances and meaningful results
 * with no change unless it provides useful information.
 *
 * Consistency across instructions means that all instructions that are special cases of more
 * general instructions affect the condition codes in the same way. Consistency across uses
 * means that conditional instructions test the condition codes similarly and provide the same
 * results whether a compare, test, or move instruction sets the condition codes. Consistency
 * across instances means that all instances of an instruction affect the condition codes in the
 * same way.
 *
 * The first four bits represent a condition of the result generated by an operation. The fifth bit
 * or the extend bit (X-bit) is an operand for multiprecision computations. The carry bit (C-bit)
 * and the X-bit are separate in the M68000 family to simplify programming techniques that use
 * them (refer to Table 3-18 as an example). In the instruction set definitions, the CCR is
 * illustrated as follows:
 *
 * X—Extend
 * Set to the value of the C-bit for arithmetic operations; otherwise not affected or set to a
 * specified result.
 *
 * N—Negative
 * Set if the most significant bit of the result is set; otherwise clear.
 *
 * Z—Zero
 * Set if the result equals zero; otherwise clear.
 *
 * V—Overflow
 * Set if an arithmetic overflow occurs implying that the result cannot be represented in the
 * operand size; otherwise clear.
 *
 */

/* VECTOR BASE REGISTER : 32 BITS */
var VBR = new Uint8Array(1);
/**
 * The VBR contains the base address of the exception vector table in memory. The
 * displacement of an exception vector adds to the value in this register, which accesses the
 * vector table.
 */

/* ALTERNATE FUNCTION CODE REGISTERS : 32 BITS */
var SFC = new Uint8Array(1);
var DFC = new Uint8Array(1);
/**
 * The alternate function code registers contain 3-bit function codes. Function codes can be
 * considered extensions of the 32-bit logical address that optionally provides as many as eight
 * 4-Gbyte address spaces. The processor automatically generates function codes to select
 * address spaces for data and programs at the user and supervisor modes. Certain
 * instructions use SFC and DFC to specify the function codes for operations.
 */

var WORD_LENGTH = 2; // bytes
var BYTE_LENGTH = 1; // bytes

/**
 * These are the major opcodes.  I'm not sure yet what to store in this map, since the major opcodes don't
 * correspond directly to the length of the opcode+operands.  Perhaps it can store something like "IF this_major_opcode,
 * THEN check_this_next_for_the_word_length".
 *
 * The text is only temporary.
 *
 * They are drawn from the 68k Programmer's Reference Manual page 561, Operation Code Map, section 8.2.
 * The text in the parenthesis comes from [http://www.mactech.com/articles/mactech/Vol.10/10.09/Emulation/index.html].
 * I included it because the guy seems to know the 68k intimately, and his text differs somewhat from the PRM's.
 *
 * Key to Instruction formats:
 *
 *     -   Undefined
 *     A1  Single-Operand Address Mode in 5-0
 *     A2  Double-Operand Address Modes in 11-0
 *     D   Data or Offset in 7-0
 */
var MAJOR_OPCODES = {
    0000 : "Bit Manipulation, MOVEP, Immediate operations",                                 // A1  Bit Manipulation, MOVEP, Immediate operations
    0001 : "Move Byte",                                                                     // A2  Move Byte
    0010 : "Move Long",                                                                     // A2  Move Long
    0011 : "Move Word (Move Short)",                                                        // A2  Move Word (Move Short)
    0100 : "Miscellaneous",                                                                 // A1  Miscellaneous
    0101 : "ADDQ/SUBQ/Scc/DBcc/TRAPc c (Add/Sub Quick & CC)",                               // A1  ADDQ/SUBQ/Scc/DBcc/TRAPc c (Add/Sub Quick & CC)
    0110 : "Bcc/BSR/BRA (Branch operations)",                                               // D   Bcc/BSR/BRA (Branch operations)
    0111 : "MOVEQ (Move Quick)",                                                            // D   MOVEQ (Move Quick)
    1000 : "OR/DIV/SBCD (Or & Divide)",                                                     // A1  OR/DIV/SBCD (Or & Divide)
    1001 : "SUB/SUBX (Subtract)",                                                           // A1  SUB/SUBX (Subtract)
    1010 : "Unassigned/Reserved (Illegal (A-Traps))",                                       // -   Unassigned/Reserved (Illegal (A-Traps))
    1011 : "CMP/EOR (Compare & Xor)",                                                       // A1  CMP/EOR (Compare & Xor)
    1100 : "AND/MUL/ABCD/EXG (And & Multiply)",                                             // A1  AND/MUL/ABCD/EXG (And & Multiply)
    1101 : "ADD/ADDX (Add)",                                                                // A1  ADD/ADDX (Add)
    1110 : "Shift/Rotate/Bit Field (Shift & Rotate)",                                       // A1  Shift/Rotate/Bit Field (Shift & Rotate)
    1111 : "Coprocessor Interface/MC68040 and CPU32 Extensions (Illegal (Floating-point))", // -   Coprocessor Interface/MC68040 and CPU32 Extensions (Illegal (Floating-point))
}

function decode_A1( _word ) {
    // TODO : return here
}
function decode_A2( _word ) {
}
function decode_D( _word ) {
}
function decode_undefined( _word ) {
}

var DECODE_ADDRESSING_MODE = [
    decode_A1,        // 0000
    decode_A2,        // 0001
    decode_A2,        // 0010
    decode_A2,        // 0011
    decode_A1,        // 0100
    decode_A1,        // 0101
    decode_D,         // 0110
    decode_D,         // 0111
    decode_A1,        // 1000
    decode_A1,        // 1001
    decode_undefined, // 1010
    decode_A1,        // 1011
    decode_A1,        // 1100
    decode_A1,        // 1101
    decode_A1,        // 1110
    decode_undefined  // 1111
]

/* MEMORY */
var memory = new ArrayBuffer( 32 );
var mem    = new DataView( memory );

/* DISPLAY */
var PAL_RES = { x : 320, y : 256 };
var NTSC_RES = { x : 320, y : 200 };

// D0 located at 0x000 and D1 at 0x001 just for the hell of it.
var FAKE_ADD = 0xD1C791C7; // this is TWO add opcodes
                           // 1101 = add
                           // 000  = D0
                           // 000  = opmode (byte ea+dn->dn)
                           // 000  = addressing mode (dn)
                           // 001  = D1
                           // 1101 000 000 000 001 = 0xD001

/* add some opcodes to memory */
mem.setUint32( 0, FAKE_ADD, false );
mem.setUint32( 4, FAKE_ADD, false );

var b0000 = parseInt( 0000, 2 );
var b0001 = parseInt( 0001, 2 );
var b0010 = parseInt( 0010, 2 );
var b0011 = parseInt( 0011, 2 );
var b0100 = parseInt( 0100, 2 );
var b0101 = parseInt( 0101, 2 );
var b0110 = parseInt( 0110, 2 );
var b0111 = parseInt( 0111, 2 );
var b1000 = parseInt( 1000, 2 );
var b1001 = parseInt( 1001, 2 );
var b1010 = parseInt( 1010, 2 );
var b1011 = parseInt( 1011, 2 );
var b1100 = parseInt( 1100, 2 );
var b1101 = parseInt( 1101, 2 );
var b1110 = parseInt( 1110, 2 );
var b1111 = parseInt( 1111, 2 );

var stop_execution = false;

window.onload = function() {
    while( !stop_execution ) {

        switch( ( mem.getUint16( PC[0] ) >> 4 ) ) {
            case b0000: UNIMPLEMENTED( b0000 ); break;
            case b0001: UNIMPLEMENTED( b0001 ); break;
            case b0010: UNIMPLEMENTED( b0010 ); break;
            case b0011: UNIMPLEMENTED( b0011 ); break;
            case b0100: UNIMPLEMENTED( b0100 ); break;
            case b0101: UNIMPLEMENTED( b0101 ); break;
            case b0110: UNIMPLEMENTED( b0110 ); break;
            case b0111: UNIMPLEMENTED( b0111 ); break;
            case b1000: UNIMPLEMENTED( b1000 ); break;
            case b1001: UNIMPLEMENTED( b1001 ); break;
            case b1010: UNIMPLEMENTED( b1010 ); break;
            case b1011: UNIMPLEMENTED( b1011 ); break;
            case b1100: UNIMPLEMENTED( b1100 ); break;

            case b1101:
                var opcode = mem.getUint16(PC[0]);
                var regsrc = ( opcode >> 9 ) & 0x7;
                var opmode = ( opcode >> 6 ) & 0x7;
                var eamode = ( opcode >> 3 ) & 0x7;
                var regsnk = ( opcode      ) & 0x7;

                console.log( "PARTIALLY IMPLEMENTED : %s at PC=%d\n" +
                    "\tregsrc : %s\n"+
                    "\topmode : %s\n"+
                    "\teamode : %s\n"+
                    "\tregsnk : %s",
                    MAJOR_OPCODES[ ( opcode >> 12 ).toString(2) ],
                    PC[0],
                    regsrc.toString(2),
                    opmode.toString(2),
                    eamode.toString(2),
                    regsnk.toString(2)
                    );

                PC[0] += WORD_LENGTH; // 1101 opcodes are 1 word wide
                break;

            case b1110: UNIMPLEMENTED( b1110 ); break;
            case b1111: UNIMPLEMENTED( b1111 ); break;

            default:
                console.log('default case; halting execution');
                stop_execution = true;
                break;
        }
    }
}


function UNIMPLEMENTED( _major_opcode ) {
    console.log("UNIMPLEMENTED @ PC=%d : %s", PC[0], MAJOR_OPCODES[ _major_opcode.toString(2) ] );
    stop_execution=true;
    PC[0] += WORD_LENGTH;
}
