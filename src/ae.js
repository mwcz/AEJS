/**
 * integer to binary
 * translates a number into a binary representation of that number
 */
function itob( _num ) {
    return (_num).toString(2); 
}

/* DATA REGISTERS : 32 BITS */
var D = new Uint32Array( 8 );
/* these are general-purpose data registers */

/* ADDRESS REGISTERS : 32 BITS */
var A = new Uint32Array( 8 );
/* these are used as pointers, generally */

/* STACK POINTER : 32 BITS */
// A[7] is the stack pointer

/**
 * In the supervisor programming model register, A7 refers to the interrupt stack pointer,
 * A7’(ISP) and the master stack pointer, A7" (MSP). The supervisor stack pointer is the active
 * stack pointer (ISP or MSP). For processors that do not support ISP or MSP, the system stack
 * is the system stack pointer (SSP). The ISP and MSP are general- purpose address registers
 * for the supervisor mode. They can be used as software stack pointers, index registers, or
 * base address registers. The ISP and MSP can be used for word and long-word operations.
 */
/**
 * Register A7 is used as a hardware stack pointer during stacking for subroutine calls and
 * exception handling. In the user programming model, A7 refers to the user stack pointer
 * (USP).
 */

/* PROGRAM COUNTER : 32 BITS */
var PC = new Uint8Array(1);
/**
 * The PC contains the address of the instruction currently executing. During instruction
 * execution and exception processing, the processor automatically increments the contents
 * or places a new value in the PC. For some addressing modes, the PC can be used as a
 * pointer for PC relative addressing.
 */

/* STATUS REGISTER : 32 BITS */
var SR = new Uint8Array(1);
/*
    15   14  13  12  11  10  9   8   7   6   5   4   3   2   1   0
    T1   T0  S   M   0   I2  I1  I0  0   0   0   X   N   Z   V   C

    Bit Description
    C   Carry
    V   Overflow
    Z   Zero
    N   Negative
    X   Extend
    I0  Interrupt priority mask bit 1
    I1  Interrupt priority mask bit 2
    I2  Interrupt priority mask bit 3
    M   Master/Interrupt switch. Determines which stack mode to use if S is set. If M is clear, SP refers to ISP, else SP refers to MSP. This bit is always clear on processor models lower than 68020.
    S   Supervisor Mode flag. If clear, SP refers to USP. If set, look at M to determine what stack SP points to.
    T0  Trace bit 1. If set, trace on change of program flow. This bit is always cleared on processor models lower than 68020.
    T1  Trace bit 2. If set, trace is allowed on any instruction. DO NOT SET BOTH TRACE BITS AT THE SAME TIME!

    (in user mode, only the low bit is accessible.  in supervisor mode, all bits can be read)
*/

/* CONDITION CODE REGISTER : 8 BITS */
var CCR = new Uint8Array(1);
/**
 * 1.1.4 Condition Code Register
 *
 * Consisting of five bits, the CCR, the status register’s lower byte, is the only portion of the
 * status register (SR) available in the user mode. Many integer instructions affect the CCR,
 * indicating the instruction’s result. Program and system control instructions also use certain
 * combinations of these bits to control program and system flow. The condition codes meet
 * two criteria: consistency across instructions, uses, and instances and meaningful results
 * with no change unless it provides useful information.
 *
 * Consistency across instructions means that all instructions that are special cases of more
 * general instructions affect the condition codes in the same way. Consistency across uses
 * means that conditional instructions test the condition codes similarly and provide the same
 * results whether a compare, test, or move instruction sets the condition codes. Consistency
 * across instances means that all instances of an instruction affect the condition codes in the
 * same way.
 *
 * The first four bits represent a condition of the result generated by an operation. The fifth bit
 * or the extend bit (X-bit) is an operand for multiprecision computations. The carry bit (C-bit)
 * and the X-bit are separate in the M68000 family to simplify programming techniques that use
 * them (refer to Table 3-18 as an example). In the instruction set definitions, the CCR is
 * illustrated as follows:
 *
 * X—Extend
 * Set to the value of the C-bit for arithmetic operations; otherwise not affected or set to a
 * specified result.
 *
 * N—Negative
 * Set if the most significant bit of the result is set; otherwise clear.
 *
 * Z—Zero
 * Set if the result equals zero; otherwise clear.
 *
 * V—Overflow
 * Set if an arithmetic overflow occurs implying that the result cannot be represented in the
 * operand size; otherwise clear.
 *
 */

/* VECTOR BASE REGISTER : 32 BITS */
var VBR = new Uint8Array(1);
/**
 * The VBR contains the base address of the exception vector table in memory. The
 * displacement of an exception vector adds to the value in this register, which accesses the
 * vector table.
 */

/* ALTERNATE FUNCTION CODE REGISTERS : 32 BITS */
var SFC = new Uint8Array(1);
var DFC = new Uint8Array(1);
/**
 * The alternate function code registers contain 3-bit function codes. Function codes can be
 * considered extensions of the 32-bit logical address that optionally provides as many as eight
 * 4-Gbyte address spaces. The processor automatically generates function codes to select
 * address spaces for data and programs at the user and supervisor modes. Certain
 * instructions use SFC and DFC to specify the function codes for operations.
 */

var WORD_LENGTH = 2; // bytes
var BYTE_LENGTH = 1; // bytes

/**
 * These are the major opcodes.  I'm not sure yet what to store in this map, since the major opcodes don't
 * correspond directly to the length of the opcode+operands.  Perhaps it can store something like "IF this_major_opcode,
 * THEN check_this_next_for_the_word_length".
 *
 * The text is only temporary.
 *
 * They are drawn from the 68k Programmer's Reference Manual page 561, Operation Code Map, section 8.2.
 * The text in the parenthesis comes from [http://www.mactech.com/articles/mactech/Vol.10/10.09/Emulation/index.html].
 * I included it because the guy seems to know the 68k intimately, and his text differs somewhat from the PRM's.
 *
 * Key to Instruction formats:
 *
 *     -   Undefined
 *     A1  Single-Operand Address Mode in 5-0
 *     A2  Double-Operand Address Modes in 11-0
 *     D   Data or Offset in 7-0
 */
var MAJOR_OPCODES = [
    /* 0000 */ "[A1] Bit Manipulation, MOVEP, Immediate operations",                                 // A1  Bit Manipulation, MOVEP, Immediate operations
    /* 0001 */ "[A2] Move Byte",                                                                     // A2  Move Byte
    /* 0010 */ "[A2] Move Long",                                                                     // A2  Move Long
    /* 0011 */ "[A2] Move Word (Move Short)",                                                        // A2  Move Word (Move Short)
    /* 0100 */ "[A1] Miscellaneous",                                                                 // A1  Miscellaneous
    /* 0101 */ "[A1] ADDQ/SUBQ/Scc/DBcc/TRAPc c (Add/Sub Quick & CC)",                               // A1  ADDQ/SUBQ/Scc/DBcc/TRAPc c (Add/Sub Quick & CC)
    /* 0110 */ "[D]  Bcc/BSR/BRA (Branch operations)",                                               // D   Bcc/BSR/BRA (Branch operations)
    /* 0111 */ "[D]  MOVEQ (Move Quick)",                                                            // D   MOVEQ (Move Quick)
    /* 1000 */ "[A1] OR/DIV/SBCD (Or & Divide)",                                                     // A1  OR/DIV/SBCD (Or & Divide)
    /* 1001 */ "[A1] SUB/SUBX (Subtract)",                                                           // A1  SUB/SUBX (Subtract)
    /* 1010 */ "[-]  Unassigned/Reserved (Illegal (A-Traps))",                                       // -   Unassigned/Reserved (Illegal (A-Traps))
    /* 1011 */ "[A1] CMP/EOR (Compare & Xor)",                                                       // A1  CMP/EOR (Compare & Xor)
    /* 1100 */ "[A1] AND/MUL/ABCD/EXG (And & Multiply)",                                             // A1  AND/MUL/ABCD/EXG (And & Multiply)
    /* 1101 */ "[A1] ADD/ADDX (Add)",                                                                // A1  ADD/ADDX (Add)
    /* 1110 */ "[A1] Shift/Rotate/Bit Field (Shift & Rotate)",                                       // A1  Shift/Rotate/Bit Field (Shift & Rotate)
    /* 1111 */ "[-]  Coprocessor Interface/MC68040 and CPU32 Extensions (Illegal (Floating-point))", // -   Coprocessor Interface/MC68040 and CPU32 Extensions (Illegal (Floating-point))
];

function decode_A1( _word ) {
    return _word | MASK6B; // single operand address mode in 5-0
}
function decode_A2( _word ) {
    return _word | MASK12B; // double operand address mode in 11-0
}
function decode_D( _word ) {
    return _word | MASK8B; // data or offset in 7-0
}
function decode_undefined( _word ) {
}

/**
 * DECODE_ADDRESSING_MODE is a map from the first four bits of an opcode (the "major opcode")
 * to the function that decodes the addressing mode of that opcode.
 */
var DECODE_ADDRESSING_MODE = [
    /* 0000 */ decode_A1,
    /* 0001 */ decode_A2,
    /* 0010 */ decode_A2,
    /* 0011 */ decode_A2,
    /* 0100 */ decode_A1,
    /* 0101 */ decode_A1,
    /* 0110 */ decode_D,
    /* 0111 */ decode_D,
    /* 1000 */ decode_A1,
    /* 1001 */ decode_A1,
    /* 1010 */ decode_undefined,
    /* 1011 */ decode_A1,
    /* 1100 */ decode_A1,
    /* 1101 */ decode_A1,
    /* 1110 */ decode_A1,
    /* 1111 */ decode_undefined
];

/* MEMORY */
var memory = new ArrayBuffer( 32 );
var mem    = new DataView( memory );

/* DISPLAY */
var PAL_RES  = { x : 320, y : 256 };
var NTSC_RES = { x : 320, y : 200 };

// D0 located at 0x000 and D1 at 0x001 just for the hell of it.
var FAKE_OPS = 0xD1C791C7; // this is TWO add opcodes
                            /********
                             * ADD  *
                             * 1101 *
                             * 0001 *
                             * 1100 *
                             * 0111 *
                             *      *
                             * SUB  *
                             * 1001 *
                             * 0001 *
                             * 1100 *
                             * 0111 *
                             ********/

/* add some opcodes to memory */
mem.setUint32( 0, FAKE_OPS, false );
//mem.setUint32( 4, FAKE_OPS, false );

var b0000 = 0x0;
var b0001 = 0x1;
var b0010 = 0x2;
var b0011 = 0x3;
var b0100 = 0x4;
var b0101 = 0x5;
var b0110 = 0x6;
var b0111 = 0x7;
var b1000 = 0x8;
var b1001 = 0x9;
var b1010 = 0xA;
var b1011 = 0xB;
var b1100 = 0xC;
var b1101 = 0xD;
var b1110 = 0xE;
var b1111 = 0xF;

// Binary masks from 1 bit up to 16 bits
var MASK1B  = 0x1    ; // 1
var MASK2B  = 0x3    ; // 11
var MASK3B  = 0x7    ; // 111
var MASK4B  = 0xF    ; // 1111
var MASK5B  = 0x1F   ; // 11111
var MASK6B  = 0x3F   ; // 111111
var MASK7B  = 0x7F   ; // 1111111
var MASK8B  = 0xFF   ; // 11111111
var MASK9B  = 0x1FF  ; // 111111111
var MASK10B = 0x3FF  ; // 1111111111
var MASK11B = 0x7FF  ; // 11111111111
var MASK12B = 0xFFF  ; // 111111111111
var MASK13B = 0x1FFF ; // 1111111111111
var MASK14B = 0x3FFF ; // 11111111111111
var MASK15B = 0x7FFF ; // 111111111111111
var MASK16B = 0xFFFF ; // 1111111111111111

var stop_execution = false;

var fetch16 = new Uint16Array( 1 );

window.onload = function() {

    // main emulation loop
    while( !stop_execution ) {

        // Fetch the first (and perhaps only) two bytes of the next instruction
        fetch16 = mem.getUint16( PC[0] );
        fetch4  = fetch16 >> 12;

        PC[0] += WORD_LENGTH;

        console.log( "OPCODE @ PC=%d : %s",     PC[0], MAJOR_OPCODES[ ( fetch4 ) ] );
        console.log( "    BINARY OPCODE  : %s", itob( fetch16 ) );
        console.log( "    GENERALIZED OP : %s", itob( DECODE_ADDRESSING_MODE[ fetch4 ]( fetch16 ) ) );

        switch( fetch16 >> 12 ) { // isolate the major four bits to determine the "major opcode" (not sure if this is an official term)
            case b0000: UNIMPLEMENTED( b0000 ); break;
            case b0001: UNIMPLEMENTED( b0001 ); break;
            case b0010: UNIMPLEMENTED( b0010 ); break;
            case b0011: UNIMPLEMENTED( b0011 ); break;
            case b0100: UNIMPLEMENTED( b0100 ); break;
            case b0101: UNIMPLEMENTED( b0101 ); break;
            case b0110: UNIMPLEMENTED( b0110 ); break;
            case b0111: UNIMPLEMENTED( b0111 ); break;
            case b1000: UNIMPLEMENTED( b1000 ); break;
            case b1001: UNIMPLEMENTED( b1001 ); break;
            case b1010: UNIMPLEMENTED( b1010 ); break;
            case b1011: UNIMPLEMENTED( b1011 ); break;
            case b1100: UNIMPLEMENTED( b1100 ); break;

            case b1101:
                var regsrc = ( fetch16 >> 9 ) & MASK3B;
                var opmode = ( fetch16 >> 6 ) & MASK3B;
                var eamode = ( fetch16 >> 3 ) & MASK3B;
                var regsnk = ( fetch16      ) & MASK3B;

                console.log( "    PARTIALLY IMPLEMENTED : %s at PC=%d\n" +
                    "\tregsrc : %s\n"+
                    "\topmode : %s\n"+
                    "\teamode : %s\n"+
                    "\tregsnk : %s",
                    MAJOR_OPCODES[ ( fetch16 >> 12 ) ],
                    PC[0],
                    regsrc.toString(2),
                    opmode.toString(2),
                    eamode.toString(2),
                    regsnk.toString(2)
                    );

                break;

            case b1110: UNIMPLEMENTED( b1110 ); break;
            case b1111: UNIMPLEMENTED( b1111 ); break;

            default:
                console.log('default case; halting execution');
                stop_execution = true;
                break;
        }
    }
}


function UNIMPLEMENTED( _major_opcode ) {
    console.error("UNIMPLEMENTED @ PC=%d : %s", PC[0], MAJOR_OPCODES[ _major_opcode ] );
    stop_execution=true;
}
